// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2012-2020 Association Prologin <association@prologin.org>

// This file contains all the API functions for the C++ language, and all the
// constants, enumerations and structures.
// It has been generated. You can modify the end of the file if you want, but
// do not touch the part where constants, enums, structs, and api functions are
// defined.

#pragma once

#include <string>
#include <vector>

{%- for constant in game.constant %}
{{ constant.cst_comment|cxx_comment(doc=True) }}
#define {{ constant.cst_name }} {{ constant.cst_val }}
{% endfor %}

{%- for enum in game.enum %}

{{ enum.enum_summary|cxx_comment(doc=True) }}
typedef enum {{ enum.enum_name }}
{
    {%- for field_name, field_comment in enum.enum_field %}
    {{ field_name|upper }}, ///< {{ field_comment }}
    {%- endfor %}
} {{ enum.enum_name }};
{% endfor %}

{%- for struct in game.struct %}
{{ struct.str_summary|cxx_comment(doc=True) }}
typedef struct {{ struct.str_name }}
{
    {%- for field_name, field_type, field_comment in struct.str_field %}
    {{ field_type|cxx_type }} {{ field_name }}; ///< {{ field_comment }}
    {%- endfor %}
} {{ struct.str_name }};
{% endfor %}

{%- for func in game.function %}
{{ func.fct_summary|cxx_comment(doc=True) }}
{{ func.fct_ret_type|cxx_type }} {{ func.fct_name }}({{ func.fct_arg|cxx_args }});
{% endfor %}

{%- for enum in game.enum %}
/// Affiche le contenu d'une enum de type {{ enum.enum_name }}
void afficher_{{ enum.enum_name }}({{ enum.enum_name }} v);
{% endfor %}

{%- for struct in game.struct %}
/// Affiche le contenu d'une struct de type {{ struct.str_name }}
void afficher_{{ struct.str_name }}({{ struct.str_name }} v);
{% endfor %}
// -----
// API ends here, you can stop reading now.
// The rest of the file is generated operators for the structs defined above.
// You can safely modify them if you want, they are only helpers for you
// -----

namespace std {
template <typename T>
struct hash<std::vector<T>>
{
    std::size_t operator()(const std::vector<T>& v) const
    {
        std::size_t res = v.size();
        for (const auto& e : v)
            res ^= std::hash<T>()(e) + 0x9e3779b9 + (res << 6) + (res >> 2);
        return res;
    }
};
} // namespace std

{% for struct in game.struct -%}
inline bool operator==(const {{ struct.str_name }}& a, const {{ struct.str_name }}& b)
{
    {%- for field_name, _, _ in struct.str_field %}
    if (a.{{ field_name }} != b.{{ field_name }})
        return false;
    {%- endfor %}
    return true;
}

inline bool operator!=(const {{ struct.str_name }}& a, const {{ struct.str_name }}& b)
{
    return !(a == b);
}

inline bool operator<(const {{ struct.str_name }}& a, const {{ struct.str_name }}& b)
{
    {%- for field_name, _, _ in struct.str_field %}
    if (a.{{ field_name }} < b.{{ field_name }})
        return true;
    if (a.{{ field_name }} > b.{{ field_name }})
        return false;
    {%- endfor %}
    return false;
}

inline bool operator>(const {{ struct.str_name }}& a, const {{ struct.str_name }}& b)
{
    {%- for field_name, _, _ in struct.str_field %}
    if (a.{{ field_name }} > b.{{ field_name }})
        return true;
    if (a.{{ field_name }} < b.{{ field_name }})
        return false;
    {%- endfor %}
    return false;
}

namespace std {
template <>
struct hash<position>
{
    std::size_t operator()(const position& s) const
    {
        std::size_t res = 0;
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.x);
        res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.y);
        return res;
    }
};
} // namespace std
{% endfor %}
