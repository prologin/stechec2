// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2020 Association Prologin <association@prologin.org>

// This file contains the code to call the API functions from the C language.
// {{ stechec2_generated }}

#include <vector>
#include <string>

extern "C" {
#include "api.h"
}

template<typename CType, typename CxxType>
CxxType c_to_cxx(CType in)
{
    return in;
}

template<>
std::string c_to_cxx<char*, std::string>(char* in)
{
    return in;
}

template<typename CType, typename CType_array, typename CxxType>
std::vector<CxxType> c_to_cxx_array(CType_array in)
{
    std::vector<CxxType> out(in.length);
    for (size_t i = 0; i < in.length; ++i)
        out[i] = c_to_cxx<CType, CxxType>(in.items[i]);
    return out;
}

template<typename CType, typename CxxType>
CType cxx_to_c(CxxType in)
{
    return in;
}

template<>
char* cxx_to_c<char*, std::string>(std::string in)
{
    size_t l = in.length();
    char* out = (char *) malloc(l + 1);
    for (size_t i = 0; i < l; i++)
        out[i] = in[i];
    out[l] = 0;
    return out;
}

template<typename CType, typename CType_array, typename CxxType>
CType_array cxx_to_c_array(const std::vector<CxxType>& in)
{
    CType_array out = { NULL, in.size() };
    out.items = (CType *)malloc((out.length) * sizeof(CType));
    for (size_t i = 0; i < out.length; ++i)
        out.items[i] = cxx_to_c<CType, CxxType>(in[i]);
    return out;
}
{% for struct in game.struct %}
{% set c_type = struct.str_name %}
{% set cxx_type = '__internal__cxx__' + struct.str_name %}


{{ struct.str_summary|cxx_comment(doc=True) }}

typedef struct {{ cxx_type }}
{
    {% for field_name, field_type, field_comment in struct.str_field %}
    {{ field_type|c_internal_cxx_type }} {{ field_name }}; ///< {{ field_comment }}
    {% endfor %}
} {{ cxx_type }};

template<>
{{ cxx_type }} c_to_cxx<{{ c_type }}, {{ cxx_type }}>({{ c_type }} in)
{
    {{ cxx_type }} out;
    {% for field_name, field_type, field_comment in struct.str_field %}
    out.{{ field_name }} = {{ field_type|cxx_to_c }}(in.{{ field_name }});
    {% endfor %}
    return out;
}

template<>
{{ c_type }} cxx_to_c<{{ c_type }}, {{ cxx_type }}>({{ cxx_type }} in)
{
    {{ c_type }} out;
    {% for field_name, field_type, field_comment in struct.str_field %}
    out.{{ field_name }} = {{ field_type|c_to_cxx }}(in.{{ field_name }});
    {% endfor %}
    return out;
}
{% endfor %}

{% for func in game.function %}

extern "C" {{ func|c_internal_cxx_prototype(prefix='api_') }};

extern "C" {{ func|c_prototype }}
{
    {% if func is returning %}
    return {{ func.fct_ret_type|cxx_to_c }}({% endif -%}
    api_{{ func.fct_name }}(
        {%- for arg_name, arg_type, arg_comment in func.fct_arg %}
        {{- arg_type|c_to_cxx }}({{ arg_name }}){% if not loop.last %}, {% endif %}
        {% endfor -%}
    ){% if func is returning %}){% endif %};
}
{% endfor %}
{% for enum in game.enum %}

extern "C" void api_afficher_{{ enum.enum_name }}({{ enum.enum_name }} v);
void afficher_{{ enum.enum_name }}({{ enum.enum_name }} v)
{
    api_afficher_{{ enum.enum_name }}(v);
}
{% endfor %}
{% for struct in game.struct %}

extern "C" void api_afficher_{{ struct.str_name }}({{ struct.str_name|c_internal_cxx_type }} v);
void afficher_{{ struct.str_name }}({{ struct.str_name }} v)
{
    api_afficher_{{ struct.str_name }}({{ struct.str_name|c_to_cxx }}(v));
}
{% endfor %}
