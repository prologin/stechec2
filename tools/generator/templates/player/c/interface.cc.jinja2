// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2020 Association Prologin <association@prologin.org>

// This file is generated. It contains the code to call the API functions from
// the C++ language. Do not edit this file.

#include <vector>
#include <string>

extern "C" {
#include "api.h"
}

template<typename Lang, typename Cxx>
Cxx lang2cxx(Lang in)
{
  return in;
}

template<>
std::string lang2cxx<char*, std::string>(char* in)
{
  return in;
}

template<typename Lang, typename Lang_array, typename Cxx>
std::vector<Cxx> lang2cxx_array(Lang_array in)
{
  std::vector<Cxx> out(in.length);
  for (size_t i = 0; i < in.length; ++i)
    out[i] = lang2cxx<Lang, Cxx>(in.datas[i]);
  return out;
}

template<typename Lang, typename Cxx>
Lang cxx2lang(Cxx in)
{
  return in;
}

template<>
char* cxx2lang<char*, std::string>(std::string in)
{
  size_t l = in.length();
  char* out = (char *) malloc(l + 1);
  for (size_t i = 0; i < l; i++) out[i] = in[i];
  out[l] = 0;
  return out;
}

template<typename Lang, typename Lang_array, typename Cxx>
Lang_array cxx2lang_array(const std::vector<Cxx>& in)
{
  Lang_array out = { NULL, in.size() };
  out.datas = (Lang *)malloc((out.length) * sizeof(Lang));
  for (size_t i = 0; i < out.length; ++i)
    out.datas[i] = cxx2lang<Lang, Cxx>(in[i]);
  return out;
}
{% for struct in game.struct %}
{% set c_type = struct.str_name %}
{% set cxx_type = '__internal__cxx__' + struct.str_name %}


{{ struct.str_summary|cxx_comment(doc=True) }}

typedef struct {{ cxx_type }}
{
    {% for field_name, field_type, field_comment in struct.str_field %}
    {{ field_type|c_internal_cxx_type }} {{ field_name }}; ///< {{ field_comment }}
    {% endfor %}
} {{ cxx_type }};

template<>
{{ cxx_type }} lang2cxx<{{ c_type }}, {{ cxx_type }}>({{ c_type }} in)
{
    {{ cxx_type }} out;
    {% for field_name, field_type, field_comment in struct.str_field %}
    out.{{ field_name }} = {{ field_type|c_cxx2lang }}(in.{{ field_name }});
    {% endfor %}
    return out;
}

template<>
{{ c_type }} cxx2lang<{{ c_type }}, {{ cxx_type }}>({{ cxx_type }} in)
{
    {{ c_type }} out;
    {% for field_name, field_type, field_comment in struct.str_field %}
    out.{{ field_name }} = {{ field_type|c_lang2cxx }}(in.{{ field_name }});
    {% endfor %}
    return out;
}
{% endfor %}

{% for func in game.function %}

extern "C" {{ func|c_internal_cxx_prototype(prefix='api_') }};

extern "C" {{ func|c_prototype }}
{
    {% if func is returning %}
    return {{ func.fct_ret_type|c_cxx2lang }}({% endif -%}
    api_{{ func.fct_name }}(
        {% for arg_name, arg_type, arg_comment in func.fct_arg %}
        {{ arg_type|c_lang2cxx }}({{ arg_name }}){% if not loop.last %},{% endif %}
        {% endfor %}
    ){% if func is returning %}){% endif %};
}
{% endfor %}
{% for enum in game.enum %}

extern "C" void api_afficher_{{ enum.enum_name }}({{ enum.enum_name }} v);
void afficher_{{ enum.enum_name }}({{ enum.enum_name }} v)
{
    api_afficher_{{ enum.enum_name }}(v);
}
{% endfor %}
{% for struct in game.struct %}

extern "C" void api_afficher_{{ struct.str_name }}({{ struct.str_name|c_internal_cxx_type }} v);
void afficher_{{ struct.str_name }}({{ struct.str_name }} v)
{
    api_afficher_{{ struct.str_name }}({{ struct.str_name|c_lang2cxx }}(v));
}
{% endfor %}
